"use client";

import {
    createContext,
    useCallback,
    useMemo,
    useRef,
    useState,
    type RefObject,
} from "react";
import { nanoid } from "nanoid";
import type { FileUIPart } from "ai";
import type {
    AttachmentsContext,
    PromptInputControllerProps,
    PromptInputProviderProps,
} from "./types";

export const PromptInputController = createContext<PromptInputControllerProps | null>(
    null
);
export const ProviderAttachmentsContext = createContext<AttachmentsContext | null>(
    null
);
export const LocalAttachmentsContext = createContext<AttachmentsContext | null>(null);

/**
 * Optional global provider that lifts PromptInput state outside of PromptInput.
 * If you don't use it, PromptInput stays fully self-managed.
 */
export function PromptInputProvider({
    initialInput: initialTextInput = "",
    children,
}: PromptInputProviderProps) {
    // ----- textInput state
    const [textInput, setTextInput] = useState(initialTextInput);
    const clearInput = useCallback(() => setTextInput(""), []);

    // ----- attachments state (global when wrapped)
    const [attachements, setAttachements] = useState<
        (FileUIPart & { id: string })[]
    >([]);
    const fileInputRef = useRef<HTMLInputElement | null>(null);
    const openRef = useRef<() => void>(() => { });

    const add = useCallback((files: File[] | FileList) => {
        const incoming = Array.from(files);
        if (incoming.length === 0) return;

        setAttachements((prev) =>
            prev.concat(
                incoming.map((file) => ({
                    id: nanoid(),
                    type: "file" as const,
                    url: URL.createObjectURL(file),
                    mediaType: file.type,
                    filename: file.name,
                }))
            )
        );
    }, []);

    const remove = useCallback((id: string) => {
        setAttachements((prev) => {
            const found = prev.find((f) => f.id === id);
            if (found?.url) URL.revokeObjectURL(found.url);
            return prev.filter((f) => f.id !== id);
        });
    }, []);

    const clear = useCallback(() => {
        setAttachements((prev) => {
            for (const f of prev) if (f.url) URL.revokeObjectURL(f.url);
            return [];
        });
    }, []);

    const openFileDialog = useCallback(() => {
        openRef.current?.();
    }, []);

    const attachments = useMemo<AttachmentsContext>(
        () => ({
            files: attachements,
            add,
            remove,
            clear,
            openFileDialog,
            fileInputRef,
        }),
        [attachements, add, remove, clear, openFileDialog]
    );

    const __registerFileInput = useCallback(
        (ref: RefObject<HTMLInputElement | null>, open: () => void) => {
            fileInputRef.current = ref.current;
            openRef.current = open;
        },
        []
    );

    const controller = useMemo<PromptInputControllerProps>(
        () => ({
            textInput: {
                value: textInput,
                setInput: setTextInput,
                clear: clearInput,
            },
            attachments,
            __registerFileInput,
        }),
        [textInput, clearInput, attachments, __registerFileInput]
    );

    return (
        <PromptInputController.Provider value={controller}>
            <ProviderAttachmentsContext.Provider value={attachments}>
                {children}
            </ProviderAttachmentsContext.Provider>
        </PromptInputController.Provider>
    );
}
